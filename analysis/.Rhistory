for (rep in c("total", "line", "sine", "ltr", "dna", "rc")) {
head <- as.data.frame(t(setNames(c(cl, rep), c("cl", "rep"))))
# subset data for normalization
sub <- dat[!duplicated(dat$species), ]
sub <- na.omit(sub[, c("species", "rsq", "clade", paste0(rep, ".rep.median"), paste0(rep, ".rep.pct"))])
if (cl %in% c("Mammalia", "Actinopterygii", "Sauria")) {
sub <- sub[sub$clade == cl, ]
}
sub <- sub[sub$species != "Callithrix jacchus", ]
if (nrow(sub) <= 2) {
next
}
# transform and normalize
median <- 1 - (sub[[paste0(rep, ".rep.median")]]/70)
median.range <- range(na.omit(median))
sub$median.trans <- (median - median.range[1]) / diff(median.range)
vol <- sub[[paste0(rep, ".rep.pct")]] / 100
vol.range <- range(na.omit(vol))
sub$rep.prop <- (vol - vol.range[1]) / diff(vol.range)
sub <- na.omit(sub[, c("species", "rsq", "clade", "median.trans", "rep.prop")])
# prune tree and dataset based on species intersection
tree <- read.tree("../data/formatted.tree.nwk")
tree$tip.label <- gsub("_", " ", tree$tip.label)
int <- intersect(tree$tip.label, sub$species)
if (length(int) <= 2) {
next
}
pruned.tree <- keep.tip(tree, int)
sub <- sub[sub$species %in% int, ]
# find all possible GLMs
formula <- reformulate(terms[-1], "rsq")
glm.models <- dredge(glm(formula, data = sub, na.action = na.fail), subset = dc(x1, x2, x1:x2))
glm.models <- sortModels(glm.models)
# TEST
glm.models <- get.models(glm.models, subset = 1:nrow(glm.models))
glm.avg <- model.avg(glm.models)
res <- setNames((sub$rsq - predict(glm.avg, type = "response")), sub$species)
res.physig.p <- as.data.frame(t(setNames(phylosig(pruned.tree, res, method="lambda", test=TRUE)[[4]], "res.physig.p")))
if (res.physig.p < 0.05) {
cd <- comparative.data(pruned.tree, sub, names.col = "species", vcv = T)
pgls.models <- dredge(pgls(formula, data = cd), subset = dc(x1, x2, x1:x2))
pgls.models <- sortModels(pgls.models)
pgls.models <- get.models(pgls.models, subset = 1:nrow(pgls.models))
pgls.avg <- model.avg(pgls.models)
summary(pgls.avg)$coefmat.full
beta <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
} else {
summary(glm.avg)$coefmat.full
beta <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
}
lis <- list(lis, cbind(head, res.physig.p, beta, p))
}
}
# convert list into dataframe
df <- as.data.frame(do.call(rbind, lis))
View(lis)
# for each repeat in each clade in each threshold, fit a glm model where the
# response is r2 and the predictors are (divergence containing 1/2 repeat sum),
# repeat proportion, and the interaction of these two terms. then, select
# for the best model using step(). if the residuals of this model show
# phylogenetic signal, fit a PGLS model instead and select the best model using
# AIC (step() doesn't work for PGLS objects)
# helper functions
# universal ordering of a table of 5 models
sortModels <- function(x) {
first <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
!is.na(x[, terms[-1]][3]))
second <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
third <- which(is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fourth <- which(!is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fifth <- which(is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
order <- c(first, second, third, fourth, fifth)
return(x[order, ])
}
library(caper) # apply PGLS
library(data.table) # quickly read data
library(MuMIn) # calculate AIC
library(piecewiseSEM) # calculate R2 for PGLS objects
library(phytools) # phy stuff
terms <- c(
"(Intercept)",
"median.trans",
"rep.prop",
"median.trans:rep.prop"
)
dat <- fread("../results/parsed.csv")
dat <- as.data.frame(dat)
dat <- dat[!is.na(dat$chromnum.1n), ]
dat <- dat[dat$thrs == 0.8, ]
# store results a list to save memory
lis <- list()
# for each clade
for (cl in c("Total", "Mammalia", "Actinopterygii", "Sauria")) {
# for each repeat type
for (rep in c("total", "line", "sine", "ltr", "dna", "rc")) {
head <- as.data.frame(t(setNames(c(cl, rep), c("cl", "rep"))))
# subset data for normalization
sub <- dat[!duplicated(dat$species), ]
sub <- na.omit(sub[, c("species", "rsq", "clade", paste0(rep, ".rep.median"), paste0(rep, ".rep.pct"))])
if (cl %in% c("Mammalia", "Actinopterygii", "Sauria")) {
sub <- sub[sub$clade == cl, ]
}
sub <- sub[sub$species != "Callithrix jacchus", ]
if (nrow(sub) <= 2) {
next
}
# transform and normalize
median <- 1 - (sub[[paste0(rep, ".rep.median")]]/70)
median.range <- range(na.omit(median))
sub$median.trans <- (median - median.range[1]) / diff(median.range)
vol <- sub[[paste0(rep, ".rep.pct")]] / 100
vol.range <- range(na.omit(vol))
sub$rep.prop <- (vol - vol.range[1]) / diff(vol.range)
sub <- na.omit(sub[, c("species", "rsq", "clade", "median.trans", "rep.prop")])
# prune tree and dataset based on species intersection
tree <- read.tree("../data/formatted.tree.nwk")
tree$tip.label <- gsub("_", " ", tree$tip.label)
int <- intersect(tree$tip.label, sub$species)
if (length(int) <= 2) {
next
}
pruned.tree <- keep.tip(tree, int)
sub <- sub[sub$species %in% int, ]
# find all possible GLMs
formula <- reformulate(terms[-1], "rsq")
glm.models <- dredge(glm(formula, data = sub, na.action = na.fail), subset = dc(x1, x2, x1:x2))
glm.models <- sortModels(glm.models)
# TEST
glm.models <- get.models(glm.models, subset = 1:nrow(glm.models))
glm.avg <- model.avg(glm.models)
res <- setNames((sub$rsq - predict(glm.avg, type = "response")), sub$species)
res.physig.p <- as.data.frame(t(setNames(phylosig(pruned.tree, res, method="lambda", test=TRUE)[[4]], "res.physig.p")))
if (res.physig.p < 0.05) {
cd <- comparative.data(pruned.tree, sub, names.col = "species", vcv = T)
pgls.models <- dredge(pgls(formula, data = cd), subset = dc(x1, x2, x1:x2))
pgls.models <- sortModels(pgls.models)
pgls.models <- get.models(pgls.models, subset = 1:nrow(pgls.models))
pgls.avg <- model.avg(pgls.models)
summary(pgls.avg)$coefmat.full
beta <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
} else {
summary(glm.avg)$coefmat.full
beta <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
}
lis <- c(lis, list(cbind(head, res.physig.p, beta, p)))
}
}
# convert list into dataframe
df <- as.data.frame(do.call(rbind, lis))
View(df)
# helper functions
# universal ordering of a table of 5 models
sortModels <- function(x) {
first <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
!is.na(x[, terms[-1]][3]))
second <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
third <- which(is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fourth <- which(!is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fifth <- which(is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
order <- c(first, second, third, fourth, fifth)
return(x[order, ])
}
library(caper) # apply PGLS
library(data.table) # quickly read data
library(MuMIn) # calculate AIC
library(piecewiseSEM) # calculate R2 for PGLS objects
library(phytools) # phy stuff
terms <- c(
"(Intercept)",
"median.trans",
"rep.prop",
"median.trans:rep.prop"
)
dat <- fread("../results/parsed.csv")
dat <- as.data.frame(dat)
dat <- dat[!is.na(dat$chromnum.1n), ]
dat <- dat[dat$thrs == 0.8, ]
# store results a list to save memory
lis <- list()
# for each clade
for (cl in c("Total", "Mammalia", "Actinopterygii", "Sauria")) {
# for each repeat type
for (rep in c("total", "line", "sine", "ltr", "dna", "rc")) {
head <- as.data.frame(t(setNames(c(cl, rep), c("cl", "rep"))))
# subset data for normalization
sub <- dat[!duplicated(dat$species), ]
sub <- na.omit(sub[, c("species", "rsq", "clade", paste0(rep, ".rep.median"), paste0(rep, ".rep.pct"))])
if (cl %in% c("Mammalia", "Actinopterygii", "Sauria")) {
sub <- sub[sub$clade == cl, ]
}
sub <- sub[sub$species != "Callithrix jacchus", ]
if (nrow(sub) <= 2) {
next
}
# transform and normalize
median <- 1 - (sub[[paste0(rep, ".rep.median")]]/70)
median.range <- range(na.omit(median))
sub$median.trans <- (median - median.range[1]) / diff(median.range)
vol <- sub[[paste0(rep, ".rep.pct")]] / 100
vol.range <- range(na.omit(vol))
sub$rep.prop <- (vol - vol.range[1]) / diff(vol.range)
sub <- na.omit(sub[, c("species", "rsq", "clade", "median.trans", "rep.prop")])
# prune tree and dataset based on species intersection
tree <- read.tree("../data/formatted.tree.nwk")
tree$tip.label <- gsub("_", " ", tree$tip.label)
int <- intersect(tree$tip.label, sub$species)
if (length(int) <= 2) {
next
}
pruned.tree <- keep.tip(tree, int)
sub <- sub[sub$species %in% int, ]
# find all possible GLMs
formula <- reformulate(terms[-1], "rsq")
glm.models <- dredge(glm(formula, data = sub, na.action = na.fail), subset = dc(x1, x2, x1:x2))
glm.models <- sortModels(glm.models)
# TEST
glm.models <- get.models(glm.models, subset = 1:nrow(glm.models))
glm.avg <- model.avg(glm.models)
res <- setNames((sub$rsq - predict(glm.avg, type = "response")), sub$species)
res.physig.p <- as.data.frame(t(setNames(phylosig(pruned.tree, res, method="lambda", test=TRUE)[[4]], "res.physig.p")))
if (res.physig.p < 0.05) {
cd <- comparative.data(pruned.tree, sub, names.col = "species", vcv = T)
pgls.models <- dredge(pgls(formula, data = cd), subset = dc(x1, x2, x1:x2))
pgls.models <- sortModels(pgls.models)
pgls.models <- get.models(pgls.models, subset = 1:nrow(pgls.models))
pgls.avg <- model.avg(pgls.models)
summary(pgls.avg)$coefmat.full
beta <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
} else {
summary(glm.avg)$coefmat.full
beta <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
}
lis <- c(lis, list(cbind(head, res.physig.p, beta, p)))
}
}
# convert list into dataframe
df <- as.data.frame(do.call(rbind, lis))
# write
write.csv(df, file = "../results/model.average.csv", row.names = F)
df <- read.csv("../results/model.average.csv")
df <- read.csv("../results/model.average.csv")
View(df)
# for each repeat in each clade, make all 5 possible GLM models with repeat age,
# repeat proportion, and their interaction as the three predictor variables and
# R2 as the response variable. Average the 5 models. If the residuals of the
# averaged model shows phylogenetic signal, make and average PGLS models instead.
# for each model, the script will record the clade, repeat, beta coefficients,
# p values for beta coefficients, and the p value for lambda-based phylogenetic
# signal
# helper functions
# universal ordering of a table of 5 models
sortModels <- function(x) {
first <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
!is.na(x[, terms[-1]][3]))
second <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
third <- which(is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fourth <- which(!is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fifth <- which(is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
order <- c(first, second, third, fourth, fifth)
return(x[order, ])
}
library(caper) # apply PGLS
library(data.table) # quickly read data
library(MuMIn) # calculate AIC
library(piecewiseSEM) # calculate R2 for PGLS objects
library(phytools) # phy stuff
terms <- c(
"(Intercept)",
"median.trans",
"rep.prop",
"median.trans:rep.prop"
)
dat <- fread("../results/parsed.csv")
dat <- as.data.frame(dat)
dat <- dat[!is.na(dat$chromnum.1n), ]
dat <- dat[dat$thrs == 0.8, ]
# store results a list to save memory
lis <- list()
# for each clade
for (cl in c("Total", "Mammalia", "Actinopterygii", "Sauria")) {
# for each repeat type
for (rep in c("total", "line", "sine", "ltr", "dna", "rc")) {
head <- as.data.frame(t(setNames(c(cl, rep), c("cl", "rep"))))
# subset data for normalization
sub <- dat[!duplicated(dat$species), ]
sub <- na.omit(sub[, c("species", "rsq", "clade", paste0(rep, ".rep.median"), paste0(rep, ".rep.pct"))])
if (cl %in% c("Mammalia", "Actinopterygii", "Sauria")) {
sub <- sub[sub$clade == cl, ]
}
sub <- sub[sub$species != "Callithrix jacchus", ]
if (nrow(sub) <= 2) {
next
}
# transform and normalize
median <- 1 - (sub[[paste0(rep, ".rep.median")]]/70)
median.range <- range(na.omit(median))
sub$median.trans <- (median - median.range[1]) / diff(median.range)
vol <- sub[[paste0(rep, ".rep.pct")]] / 100
vol.range <- range(na.omit(vol))
sub$rep.prop <- (vol - vol.range[1]) / diff(vol.range)
sub <- na.omit(sub[, c("species", "rsq", "clade", "median.trans", "rep.prop")])
# prune tree and dataset based on species intersection
tree <- read.tree("../data/formatted.tree.nwk")
tree$tip.label <- gsub("_", " ", tree$tip.label)
int <- intersect(tree$tip.label, sub$species)
if (length(int) <= 2) {
next
}
pruned.tree <- keep.tip(tree, int)
sub <- sub[sub$species %in% int, ]
# find all possible GLMs
formula <- reformulate(terms[-1], "rsq")
glm.models <- dredge(glm(formula, data = sub, na.action = na.fail), subset = dc(x1, x2, x1:x2))
glm.models <- sortModels(glm.models)
# TEST
glm.models <- get.models(glm.models, subset = 1:nrow(glm.models))
glm.avg <- model.avg(glm.models)
res <- setNames((sub$rsq - predict(glm.avg, type = "response")), sub$species)
res.physig.p <- as.data.frame(t(setNames(phylosig(pruned.tree, res, method="lambda", test=TRUE)[[4]], "res.physig.p")))
if (res.physig.p < 0.05) {
cd <- comparative.data(pruned.tree, sub, names.col = "species", vcv = T)
pgls.models <- dredge(pgls(formula, data = cd), subset = dc(x1, x2, x1:x2))
pgls.models <- sortModels(pgls.models)
pgls.models <- get.models(pgls.models, subset = 1:nrow(pgls.models))
pgls.avg <- model.avg(pgls.models)
summary(pgls.avg)$coefmat.full
beta <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
} else {
summary(glm.avg)$coefmat.full
beta <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
}
lis <- c(lis, list(cbind(head, beta, p, res.physig.p)))
}
}
# convert list into dataframe
df <- as.data.frame(do.call(rbind, lis))
# write
write.csv(df, file = "../results/model.average.csv", row.names = F)
df <- read.csv("../results/model.average.csv")
View(df)
res.physig.p <- phylosig(pruned.tree, res, method="lambda", test=TRUE)[[4]]
res.physig.p
pgls<- FALSE
end <- data.frame(res.physig.p, pgls)
View(end)
# for each repeat in each clade, make all 5 possible GLM models with repeat age,
# repeat proportion, and their interaction as the three predictor variables and
# R2 as the response variable. Average the 5 models. If the residuals of the
# averaged model shows phylogenetic signal, make and average PGLS models instead.
# for each model, the script will record the clade, repeat, beta coefficients,
# p values for beta coefficients, and the p value for lambda-based phylogenetic
# signal
# helper functions
# universal ordering of a table of 5 models
sortModels <- function(x) {
first <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
!is.na(x[, terms[-1]][3]))
second <- which(!is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
third <- which(is.na(x[, terms[-1]][1]) &
!is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fourth <- which(!is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
fifth <- which(is.na(x[, terms[-1]][1]) &
is.na(x[, terms[-1]][2]) &
is.na(x[, terms[-1]][3]))
order <- c(first, second, third, fourth, fifth)
return(x[order, ])
}
library(caper) # apply PGLS
library(data.table) # quickly read data
library(MuMIn) # calculate AIC
library(piecewiseSEM) # calculate R2 for PGLS objects
library(phytools) # phy stuff
terms <- c(
"(Intercept)",
"median.trans",
"rep.prop",
"median.trans:rep.prop"
)
dat <- fread("../results/parsed.csv")
dat <- as.data.frame(dat)
dat <- dat[!is.na(dat$chromnum.1n), ]
dat <- dat[dat$thrs == 0.8, ]
# store results a list to save memory
lis <- list()
# for each clade
for (cl in c("Total", "Mammalia", "Actinopterygii", "Sauria")) {
# for each repeat type
for (rep in c("total", "line", "sine", "ltr", "dna", "rc")) {
head <- as.data.frame(t(setNames(c(cl, rep), c("cl", "rep"))))
# subset data for normalization
sub <- dat[!duplicated(dat$species), ]
sub <- na.omit(sub[, c("species", "rsq", "clade", paste0(rep, ".rep.median"), paste0(rep, ".rep.pct"))])
if (cl %in% c("Mammalia", "Actinopterygii", "Sauria")) {
sub <- sub[sub$clade == cl, ]
}
sub <- sub[sub$species != "Callithrix jacchus", ]
if (nrow(sub) <= 2) {
next
}
# transform and normalize
median <- 1 - (sub[[paste0(rep, ".rep.median")]]/70)
median.range <- range(na.omit(median))
sub$median.trans <- (median - median.range[1]) / diff(median.range)
vol <- sub[[paste0(rep, ".rep.pct")]] / 100
vol.range <- range(na.omit(vol))
sub$rep.prop <- (vol - vol.range[1]) / diff(vol.range)
sub <- na.omit(sub[, c("species", "rsq", "clade", "median.trans", "rep.prop")])
# prune tree and dataset based on species intersection
tree <- read.tree("../data/formatted.tree.nwk")
tree$tip.label <- gsub("_", " ", tree$tip.label)
int <- intersect(tree$tip.label, sub$species)
if (length(int) <= 2) {
next
}
pruned.tree <- keep.tip(tree, int)
sub <- sub[sub$species %in% int, ]
# find all possible GLMs
formula <- reformulate(terms[-1], "rsq")
glm.models <- dredge(glm(formula, data = sub, na.action = na.fail), subset = dc(x1, x2, x1:x2))
glm.models <- sortModels(glm.models)
# TEST
glm.models <- get.models(glm.models, subset = 1:nrow(glm.models))
glm.avg <- model.avg(glm.models)
res <- setNames((sub$rsq - predict(glm.avg, type = "response")), sub$species)
res.physig.p <- phylosig(pruned.tree, res, method="lambda", test=TRUE)[[4]]
if (res.physig.p < 0.05) {
pgls <- TRUE
cd <- comparative.data(pruned.tree, sub, names.col = "species", vcv = T)
pgls.models <- dredge(pgls(formula, data = cd), subset = dc(x1, x2, x1:x2))
pgls.models <- sortModels(pgls.models)
pgls.models <- get.models(pgls.models, subset = 1:nrow(pgls.models))
pgls.avg <- model.avg(pgls.models)
summary(pgls.avg)$coefmat.full
beta <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(pgls.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
} else {
pgls<- FALSE
summary(glm.avg)$coefmat.full
beta <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Estimate"]))
names(beta) <- c("intercept.b", "age.b", "prop.b", "interact.b")
p <- as.data.frame(t(summary(glm.avg)$coefmat.full[, "Pr(>|z|)"]))
names(p) <- c("intercept.p", "age.p", "prop.p", "interact.p")
}
end <- data.frame(res.physig.p, pgls)
lis <- c(lis, list(cbind(head, beta, p, end)))
}
}
# convert list into dataframe
df <- as.data.frame(do.call(rbind, lis))
# write
write.csv(df, file = "../results/model.average.csv", row.names = F)
df <- read.csv("../results/model.average.csv")
View(df)
