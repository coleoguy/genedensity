# abline(v = 0, lty = 1, lwd = 2, col = "grey") # line at y = 0
abline(v = 0, lty = 5, lwd = 1, col = "black") # line at y = 0
# for (l in -100:4) {
#   abline(v = l, lty = 2, col = "grey") # vertical lines
# }
segments(combined.df$lower, y, combined.df$upper, y, lwd = 1.4) # confidence bars
segments(combined.df$upper, y-0.2, combined.df$upper, y+0.2, lwd = 1.4)
segments(combined.df$lower, y-0.2, combined.df$lower, y+0.2, lwd = 1.4)
points(combined.df$estimate, y, pch = 16, cex = 2, col = cols) # colored points
points(combined.df$estimate, y, pch = 16, cex = 0.324, col = "white") # center dots
axis(1, at = pretty(x.range), mgp = c(1, 0.8, 0)  ) # x axis
axis(1, at = seq(-10, 10, by = 0.5), labels = FALSE, tcl = -0.2)
axis(1, at = seq(-10, 10, by = 1), labels = FALSE, tcl = -0.5)
axis(2, at = y, labels = labels, las = 2, cex.axis = 0.9) # y axis
box()
# color bar
usr <- par("usr")
bar <- array(t(col2rgb(palette)/255), c(1, length(palette), 3))
fx1 <- 0.7-0.017; fx2 <- 0.955-0.017  # x
fy1 <- 0.10-0.017; fy2 <- 0.14-0.017 # y
xleft <- usr[1] + fx1 * diff(usr[1:2])
xright <- usr[1] + fx2 * diff(usr[1:2])
ybottom <- usr[3] + fy1 * diff(usr[3:4])
ytop <- usr[3] + fy2 * diff(usr[3:4])
rasterImage(array(t(col2rgb("white") / 255), dim = c(1, 1, 3)),
xleft - 0.3, ybottom - 0.5, xright + 0.3, ytop + 0.8, interpolate = FALSE)
rasterImage(bar, xleft, ybottom - 0.05, xright, ytop, interpolate = FALSE)
axis(
side = 1,
at = seq(xleft, xright, length.out = 5),
labels = round(seq(min(imp), max(imp), length.out = 5), 2),
pos = ybottom - 0.008 * diff(usr[3:4]),
tck = -0.015,
cex.axis = 0.7,
lwd = 1,
mgp = c(1, -0.01, 1)
)
text(mean(c(xleft, xright)),
mean(c(ybottom, ytop)) + 0.53,
adj = c(0.5, 0.5), cex = 0.7,
labels = "Variable importance")
rect(xleft - 0.4, ybottom - 0.7, xright + 0.4, ytop + 0.6,
border = "black", lwd = 1)
# lines separating clades
for (j in line) {
j <- j - 1
rgb_vals <- col2rgb("white") / 255
bar <- array(t(rgb_vals), dim = c(1, 1, 3))
fx1 <- 0.02; fx2 <- 0.98  # x
xleft <- usr[1] + fx1 * diff(usr[1:2])
xright <- usr[1] + fx2 * diff(usr[1:2])
ybottom <- j - 0.13
ytop <- j + 0.13
rasterImage(bar, xleft, ybottom, xright, ytop, interpolate = FALSE)
segments(xleft, j, xright, j, lwd = 1.4, color = "")
}
# all species
par(xpd = TRUE)
text(4.8, 7.95,
adj = c(0, 0.5), cex = 0.9,
labels = "All species")
text(4.8, 7.25,
adj = c(0, 0.5), cex = 0.9,
labels = "(3827 models)")
# mammals
text(4.8, 5.45,
adj = c(0, 0.5), cex = 0.9,
labels = "Mammals")
text(4.8, 4.75,
adj = c(0, 0.5), cex = 0.9,
labels = "(2467 models)")
# fish
text(4.8, 3.45,
adj = c(0, 0.5), cex = 0.9,
labels = "Ray-finned fish")
text(4.8, 2.75,
adj = c(0, 0.5), cex = 0.9,
labels = "(1858 models)")
# reptiles
text(4.8, 0.95,
adj = c(0, 0.5), cex = 0.9,
labels = "Reptiles")
text(4.8, 0.25,
adj = c(0, 0.5), cex = 0.9,
labels = "(1045 models)")
par(xpd = FALSE)
par(mar = c(5, 4, 4, 2) + 0.1)
View(combined.df)
# Zhaobo Hu
# zhaobohu2002@gmail.com
# A permutation-based approach to assess model adequacy
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
setwd("~/GitHub/genedensity/scripts")
# Zhaobo Hu
# zhaobohu2002@gmail.com
# A permutation-based approach to assess model adequacy
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat-results.csv")
tree <- read.tree("../data/formatted-tree.nwk")
main <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
variables <- colnames(main)[grep("^(prop|age)\\.", colnames(main))]
main <- na.omit(main[, c("species", "clade", "rsq", variables)])
clades <- c("All", "Mammalia", "Actinopterygii", "Sauropsida")
constant.cols <- c("species", "clade", "rsq")
for (h in 1:2000) { # for each run
print(h)
run.results <- c()
# permute
perm.colname <- setdiff(names(main), constant.cols)
block <- main[, perm.colname]
# block
block <- block[sample(nrow(block)), ]
main[, perm.colname] <- block
for (i in 1:4) { # for each clade
dat <- main
clade <- clades[i]
# subset results
if (clade %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% clade, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# identify all predictors
repeats <- unique(sub("^[^.]*\\.", "", variables))
interactions <- paste0("age.", repeats, ":prop.", repeats)
all.terms <- c(
variables,
interactions
)
# pgls
# cd <- comparative.data(tree, dat, names.col = "species", vcv = TRUE)
# n <- nrow(cd$data)
n <- nrow(dat)
max.vars <- n-2 # leave 2 degrees of freedom
# fit models
model.list <- list()
model.idx <- 1
for (k in 1:length(all.terms)) {
if (k == 0) {
fml <- as.formula("rsq ~ 1")
# fit <- pgls(fml, data = cd)
fit <- glm(fml, data = dat)
model.name <- paste0("M", model.idx)
model.list[[model.name]] <- fit
model.idx <- model.idx + 1
next
}
combos <- combn(all.terms, k, simplify = FALSE)
for (m in combos) {
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
predictor.num <- length(attr(terms(fml), "term.labels"))
if (predictor.num >= max.vars) next
if (!model.marginal(m)) next
# fit <- pgls(fml, data = cd)
fit <- glm(fml, data = dat)
model.name <- paste0("M", model.idx)
model.list[[model.name]] <- fit
model.idx <- model.idx + 1
}
}
# create model selection table
models <- model.sel(model.list)
models <- models[order(models$AICc), ]
models <- models[cumsum(models$weight) <= 0.95, ]
rm(model.list)
gc()
# calculate CIs
ci.table <- matrix(NA, nrow = length(all.terms), ncol = 3)
colnames(ci.table) <- c("importance", "lower", "upper")
rownames(ci.table) <- all.terms
ci.table[names(sw(models)), 1] <- sw(models)
ci <- confint(model.avg(models))
ci.found <- intersect(row.names(ci), all.terms)
ci.table[ci.found, 2:3] <- ci[ci.found, ]
run.results <- c(run.results, as.numeric(ci.table))
# make initial df
if (h == 1 && i == 1) {
df <- data.frame(
dataset = rep(clades, each = length(all.terms) * 3),
stat = rep(rep(c("importance", "upper", "lower"), each = length(all.terms) / 3), 4),
variable = rep(rep(all.terms, 3), 4)
)
}
}
df[[paste0("run", h)]] <- run.results
# write.csv(df, "../results/permute.csv", row.names = F)
gc()
}
View(df)
# Zhaobo Hu
# zhaobohu2002@gmail.com
# A permutation-based approach to assess model adequacy
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat-results.csv")
tree <- read.tree("../data/formatted-tree.nwk")
main <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
variables <- colnames(main)[grep("^(prop|age)\\.", colnames(main))]
main <- na.omit(main[, c("species", "clade", "rsq", variables)])
clades <- c("All", "Mammalia", "Actinopterygii", "Sauropsida")
constant.cols <- c("species", "clade", "rsq")
for (h in 1:2000) { # for each run
print(h)
run.results <- c()
# permute
perm.colname <- setdiff(names(main), constant.cols)
block <- main[, perm.colname]
# block
block <- block[sample(nrow(block)), ]
main[, perm.colname] <- block
for (i in 1:4) { # for each clade
dat <- main
clade <- clades[i]
# subset results
if (clade %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% clade, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# identify all predictors
repeats <- unique(sub("^[^.]*\\.", "", variables))
interactions <- paste0("age.", repeats, ":prop.", repeats)
all.terms <- c(
variables,
interactions
)
# pgls
# cd <- comparative.data(tree, dat, names.col = "species", vcv = TRUE)
# n <- nrow(cd$data)
n <- nrow(dat)
max.vars <- n-2 # leave 2 degrees of freedom
# fit models
model.list <- list()
model.idx <- 1
for (k in 1:length(all.terms)) {
if (k == 0) {
fml <- as.formula("rsq ~ 1")
# fit <- pgls(fml, data = cd)
fit <- glm(fml, data = dat)
model.name <- paste0("M", model.idx)
model.list[[model.name]] <- fit
model.idx <- model.idx + 1
next
}
combos <- combn(all.terms, k, simplify = FALSE)
for (m in combos) {
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
predictor.num <- length(attr(terms(fml), "term.labels"))
if (predictor.num >= max.vars) next
if (!model.marginal(m)) next
# fit <- pgls(fml, data = cd)
fit <- glm(fml, data = dat)
model.name <- paste0("M", model.idx)
model.list[[model.name]] <- fit
model.idx <- model.idx + 1
}
}
# create model selection table
models <- model.sel(model.list)
models <- models[order(models$AICc), ]
models <- models[cumsum(models$weight) <= 0.95, ]
rm(model.list)
gc()
# calculate CIs
ci.table <- data.frame(matrix(NA, nrow = length(all.terms), ncol = 3))
colnames(ci.table) <- c("importance", "lower", "upper")
rownames(ci.table) <- all.terms
ci.table[names(sw(models)), 1] <- sw(models)
ci <- confint(model.avg(models))
ci.found <- intersect(row.names(ci), all.terms)
ci.table[ci.found, 2:3] <- ci[ci.found, ]
run.results <- c(run.results, as.numeric(ci.table))
# make initial df
if (h == 1 && i == 1) {
df <- data.frame(
dataset = rep(clades, each = length(all.terms) * 3),
stat = rep(rep(c("importance", "upper", "lower"), each = length(all.terms) / 3), 4),
variable = rep(rep(all.terms, 3), 4)
)
}
}
df[[paste0("run", h)]] <- run.results
# write.csv(df, "../results/permute.csv", row.names = F)
gc()
}
View(ci.table)
unlist(ci.table)
View(ci.table)
run.results <- c(run.results, unlist(ci.table))
run.results
# make initial df
if (h == 1 && i == 1) {
df <- data.frame(
dataset = rep(clades, each = length(all.terms) * 3),
stat = rep(rep(c("importance", "upper", "lower"), each = length(all.terms) / 3), 4),
variable = rep(rep(all.terms, 3), 4)
)
}
# Zhaobo Hu
# zhaobohu2002@gmail.com
# A permutation-based approach to assess model adequacy
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat-results.csv")
tree <- read.tree("../data/formatted-tree.nwk")
main <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
variables <- colnames(main)[grep("^(prop|age)\\.", colnames(main))]
main <- na.omit(main[, c("species", "clade", "rsq", variables)])
clades <- c("All", "Mammalia", "Actinopterygii", "Sauropsida")
constant.cols <- c("species", "clade", "rsq")
for (h in 1:2000) { # for each run
print(h)
run.results <- c()
# permute
perm.colname <- setdiff(names(main), constant.cols)
block <- main[, perm.colname]
# block
block <- block[sample(nrow(block)), ]
main[, perm.colname] <- block
for (i in 1:4) { # for each clade
dat <- main
clade <- clades[i]
# subset results
if (clade %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% clade, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# identify all predictors
repeats <- unique(sub("^[^.]*\\.", "", variables))
interactions <- paste0("age.", repeats, ":prop.", repeats)
all.terms <- c(
variables,
interactions
)
# pgls
# cd <- comparative.data(tree, dat, names.col = "species", vcv = TRUE)
# n <- nrow(cd$data)
n <- nrow(dat)
max.vars <- n-2 # leave 2 degrees of freedom
# fit models
model.list <- list()
model.idx <- 1
for (k in 1:length(all.terms)) {
if (k == 0) {
fml <- as.formula("rsq ~ 1")
# fit <- pgls(fml, data = cd)
fit <- glm(fml, data = dat)
model.name <- paste0("M", model.idx)
model.list[[model.name]] <- fit
model.idx <- model.idx + 1
next
}
combos <- combn(all.terms, k, simplify = FALSE)
for (m in combos) {
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
predictor.num <- length(attr(terms(fml), "term.labels"))
if (predictor.num >= max.vars) next
if (!model.marginal(m)) next
# fit <- pgls(fml, data = cd)
fit <- glm(fml, data = dat)
model.name <- paste0("M", model.idx)
model.list[[model.name]] <- fit
model.idx <- model.idx + 1
}
}
# create model selection table
models <- model.sel(model.list)
models <- models[order(models$AICc), ]
models <- models[cumsum(models$weight) <= 0.95, ]
rm(model.list)
gc()
# calculate CIs
ci.table <- data.frame(matrix(NA, nrow = length(all.terms), ncol = 3))
colnames(ci.table) <- c("importance", "lower", "upper")
rownames(ci.table) <- all.terms
ci.table[names(sw(models)), 1] <- sw(models)
ci <- confint(model.avg(models))
ci.found <- intersect(row.names(ci), all.terms)
ci.table[ci.found, 2:3] <- ci[ci.found, ]
run.results <- c(run.results, unlist(ci.table))
# make initial df
if (h == 1 && i == 1) {
df <- data.frame(
dataset = rep(clades, each = length(all.terms) * 3),
stat = rep(rep(c("importance", "upper", "lower"), each = length(all.terms) / 3), 4),
variable = rep(rep(all.terms, 3), 4)
)
}
}
df[[paste0("run", h)]] <- run.results
# write.csv(df, "../results/permute.csv", row.names = F)
gc()
}
View(df)
# Zhaobo Hu
# zhaobohu2002@gmail.com
# Finds significant models and predictors of R2 using IT-based model averaging.
# Safe to run on low observation count. Can choose between glm() and pgls() models
# and optionally generate a csv of all significant models
library(MuMIn)
library(phytools)
library(caper)
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat-results.csv")
tree <- read.tree("../data/formatted-tree.nwk")
combined.df <- data.frame()
clades <- c("All", "Mammalia", "Actinopterygii", "Sauropsida")
# loop for each clade
i <- 1
# subset results
clade <- clades[i]
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (clade %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% clade, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# identify all predictors
repeat.types <- unique(sub("^[^.]*\\.", "", variables))
interactions <- paste0("age.", repeat.types, ":prop.", repeat.types)
all.terms <- c(
variables,
interactions
)
# n <- nrow(cd$data)
n <- nrow(dat)
max.vars <- n-2 # leave 2 degrees of freedom
max.vars
# fit models
model.list <- list()
model.idx <- 1
i <- 8
k <- 8
k == 0
combos <- combn(all.terms, k, simplify = FALSE)
combos
m <- 1000
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
fml
m <- combos[100]
fml
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
fml
predictor.num <- length(attr(terms(fml), "term.labels"))
predictor.num
fml
predictor.num <- length(attr(terms(fml), "term.labels"))
predictor.num
fml
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
fml
m
m[[1]]
m <- m[[1]]
fml <- as.formula(paste("rsq ~", paste(m, collapse = " + ")))
fml
predictor.num <- length(attr(terms(fml), "term.labels"))
predictor.num
# Zhaobo Hu
# zhaobohu2002@gmail.com
# Finds significant models and predictors of R2 using IT-based model averaging.
# Safe to run on low observation count. Can choose between glm() and pgls() models
# and optionally generate a csv of all significant models
library(MuMIn)
library(phytools)
library(caper)
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat-results.csv")
tree <- read.tree("../data/formatted-tree.nwk")
combined.df <- data.frame()
clades <- c("All", "Mammalia", "Actinopterygii", "Sauropsida")
# loop for each clade
