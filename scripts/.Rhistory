next
}
df <- data.frame(i,
names(imp),
sapply(1:nrow(ci), function(x) mean(unlist(ci[x, ]))),
imp,
ci[, 1],
ci[, 2])
colnames(df) <- c("clade", "model", "estimate", "importance", "lower", "upper")
if (nrow(combined.df) == 0) {
combined.df <- df
} else {
combined.df <- rbind(combined.df, df)
}
}
combined.df <- combined.df[combined.df$importance > 0.5, ]
View(combined.df)
write.csv(combined.df, "../results/model.averaging.csv", row.names = F)
View(combined.df)
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat.results.csv")
combined.df <- data.frame()
# loop for each clade
for (i in c("All", "Mammalia", "Actinopterygii", "Sauropsida")) {
# subset results
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (i %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% i, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
age <- dat[grep("^age\\.", colnames(dat))]
prop <- dat[grep("^prop\\.", colnames(dat))]
l <- age * prop
dat <- cbind(dat[, c("species", "clade", "rsq")], l)
variables <- variables[c(2, 4, 6, 8, 10, 12)]
# prune tree
tree <- read.tree("../data/formatted.tree.nwk")
int <- intersect(dat$species, tree$tip.label)
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# cd <- comparative.data(pruned.tree, dat, names.col = "species", vcv = TRUE)
# global model
global.model <- glm(reformulate(variables, response = "rsq"), data = dat)
# set constraints
model.terms <- unlist(strsplit(as.character(global.model$formula)[3], " \\+ "))
if (i %in% c("All", "Sauropsida")) {
cd <- comparative.data(tree, dat, names.col = "species", vcv = TRUE)
global.model <- pgls(reformulate(variables, response = "rsq"), data = cd)
models <- dredge(global.model
#extra = list(shapirowilk.p = sw.test, lambda.p = lambda.test)
)
} else {
# dredge
models <- dredge(global.model
# extra = list(shapirowilk.p = sw.test, lambda.p = lambda.test)
)
}
models <- models[order(models$AICc), ]
models <- models[cumsum(models$weight) <= 0.95, ]
imp <- sort(sw(models), decreasing = TRUE)
avg <- model.avg(models)
ci <- confint(avg)
ci <- ci[match(names(imp), row.names(ci)), ] #match ci
ci <- as.data.frame(ci)
idx <- which(sign(ci[, 1]) == sign(ci[, 2])) # idx where 0 is not in ci
ci <- ci[idx, ]# subset ci
imp <- imp[idx]# subset importance
if (length(imp) == 0) {
next
}
df <- data.frame(i,
names(imp),
sapply(1:nrow(ci), function(x) mean(unlist(ci[x, ]))),
imp,
ci[, 1],
ci[, 2])
colnames(df) <- c("clade", "model", "estimate", "importance", "lower", "upper")
if (nrow(combined.df) == 0) {
combined.df <- df
} else {
combined.df <- rbind(combined.df, df)
}
}
combined.df <- combined.df[combined.df$importance > 0.5, ]
write.csv(combined.df, "../results/model.averaging.alt.csv", row.names = F)
View(combined.df)
library(viridis)
combined.df <- read.csv("../results/model.averaging.csv")
# x positions
x <- c()
for (i in 1:length(combined.df$clade)) {
if (is.null(x)) {
x <- c(1)
} else {
x <- c(x, ifelse(combined.df$clade[i] == prev, tail(x, 1) + 0.55, tail(x, 1) + 1))
}
prev <- combined.df$clade[i]
}
imp <- combined.df$importance
# color mapping
res <- 10000 # resolution
palette <- viridis(res, begin = 0, end = 0.8, option = "A") # palette
cols <- palette[round(((imp - min(imp)) / diff(range(imp))) * (res-1)) + 1] # colors
# x labels
labels <- c()
for (i in combined.df$model) {
rep <- toupper(regmatches(i, regexpr("(?<=\\.)[a-zA-Z]+", i, perl = TRUE)))
if (rep == "OTHERS") {
rep <- "Others"
} else if (rep == "UNKNOWN") {
rep <- "Unidtf"
}
if (grepl(":", i)) {
type <- "int."
} else if (sub("\\..*", "", i) == "prop") {
type <- "prop."
} else {
type <- "age"
}
labels <- c(labels, paste(rep, type))
}
par(oma = c(0, 0, 3, 0))
layout(matrix(1:2, ncol = 2), widths = c(4, 1)) # make 2 plots
# main plot
par(mar = c(8, 4, 1, 0))
int.range <- range(as.matrix(combined.df[c("lower", "upper")])) * 1.2
int.range[2] <- int.range[2] * 1.2
plot(y = combined.df$estimate, x = x, type = "n", ylim = int.range,
ylab = "β coefficient", xlab = NA, axes = FALSE,
xlim = c(min(x)-0.25, max(x)+0.25), useRaster = T) # plot
abline(h = 0, lty = 1, col = "black") # line at y = 0
for (l in -100:100) {
abline(h = l, lty = 2, col = "grey") # line at y = 0
}
segments(x, combined.df$lower, x, combined.df$upper, lwd = 2) # confidence bars
segments(x-0.1, combined.df$upper, x+0.1, combined.df$upper, lwd = 2)
segments(x-0.1, combined.df$lower, x+0.1, combined.df$lower, lwd = 2)
points(x, combined.df$estimate, pch = 16, cex = 0.9, col = cols) # colored points
axis(2) # y axis
axis(2, at = seq(-10, 10, by = 0.5), labels = FALSE, tcl = -0.2)
axis(2, at = seq(-10, 10, by = 1), labels = FALSE, tcl = -0.5)
axis(1, at = x, labels = labels, las = 2) # x axis
box()
# color bar
par(mar = c(8, 1, 1, 4))
height <- seq(min(imp), max(imp), length.out = res + 1) # y values
z <- matrix(seq(min(imp), max(imp), length.out = res), nrow = 1, ncol = res) # color gradient
image(x = c(0, 1), y = height, z = z, col = palette,
axes = FALSE, xlab = "", ylab = "", useRaster = T) # make color bar
ticks <- seq(min(imp), max(imp), length.out = 5) # ticks
axis(4, at = ticks, labels = round(ticks, 2), las = 1) # y axis
# title
# mtext("Parameter estimates for averaged models",
#       outer = TRUE, cex = 1.1, line = 0, font = 2, family = "sans",
#       adj = 0.35)
par(mar = c(5, 4, 4, 2) + 0.1)
library(viridis)
combined.df <- read.csv("../results/model.averaging.alt.csv")
# x positions
x <- c()
for (i in 1:length(combined.df$clade)) {
if (is.null(x)) {
x <- c(1)
} else {
x <- c(x, ifelse(combined.df$clade[i] == prev, tail(x, 1) + 0.55, tail(x, 1) + 1))
}
prev <- combined.df$clade[i]
}
imp <- combined.df$importance
# color mapping
res <- 10000 # resolution
palette <- viridis(res, begin = 0, end = 0.8, option = "A") # palette
cols <- palette[round(((imp - min(imp)) / diff(range(imp))) * (res-1)) + 1] # colors
# x labels
labels <- c()
for (i in combined.df$model) {
rep <- toupper(regmatches(i, regexpr("(?<=\\.)[a-zA-Z]+", i, perl = TRUE)))
if (rep == "OTHERS") {
rep <- "Others"
} else if (rep == "UNKNOWN") {
rep <- "Unidtf"
}
if (grepl(":", i)) {
type <- "int."
} else if (sub("\\..*", "", i) == "prop") {
type <- "prop."
} else {
type <- "age"
}
labels <- c(labels, paste(rep, type))
}
par(oma = c(0, 0, 3, 0))
layout(matrix(1:2, ncol = 2), widths = c(4, 1)) # make 2 plots
# main plot
par(mar = c(8, 4, 1, 0))
int.range <- range(as.matrix(combined.df[c("lower", "upper")])) * 1.2
int.range[2] <- int.range[2] * 1.2
plot(y = combined.df$estimate, x = x, type = "n", ylim = int.range,
ylab = "β coefficient", xlab = NA, axes = FALSE,
xlim = c(min(x)-0.25, max(x)+0.25), useRaster = T) # plot
abline(h = 0, lty = 1, col = "black") # line at y = 0
for (l in -100:100) {
abline(h = l, lty = 2, col = "grey") # line at y = 0
}
segments(x, combined.df$lower, x, combined.df$upper, lwd = 2) # confidence bars
segments(x-0.1, combined.df$upper, x+0.1, combined.df$upper, lwd = 2)
segments(x-0.1, combined.df$lower, x+0.1, combined.df$lower, lwd = 2)
points(x, combined.df$estimate, pch = 16, cex = 0.9, col = cols) # colored points
axis(2) # y axis
axis(2, at = seq(-10, 10, by = 0.5), labels = FALSE, tcl = -0.2)
axis(2, at = seq(-10, 10, by = 1), labels = FALSE, tcl = -0.5)
axis(1, at = x, labels = labels, las = 2) # x axis
box()
# color bar
par(mar = c(8, 1, 1, 4))
height <- seq(min(imp), max(imp), length.out = res + 1) # y values
z <- matrix(seq(min(imp), max(imp), length.out = res), nrow = 1, ncol = res) # color gradient
image(x = c(0, 1), y = height, z = z, col = palette,
axes = FALSE, xlab = "", ylab = "", useRaster = T) # make color bar
ticks <- seq(min(imp), max(imp), length.out = 5) # ticks
axis(4, at = ticks, labels = round(ticks, 2), las = 1) # y axis
# title
# mtext("Parameter estimates for averaged models",
#       outer = TRUE, cex = 1.1, line = 0, font = 2, family = "sans",
#       adj = 0.35)
par(mar = c(5, 4, 4, 2) + 0.1)
library(viridis)
combined.df <- read.csv("../results/model.averaging.csv")
# x positions
x <- c()
for (i in 1:length(combined.df$clade)) {
if (is.null(x)) {
x <- c(1)
} else {
x <- c(x, ifelse(combined.df$clade[i] == prev, tail(x, 1) + 0.55, tail(x, 1) + 1))
}
prev <- combined.df$clade[i]
}
imp <- combined.df$importance
# color mapping
res <- 10000 # resolution
palette <- viridis(res, begin = 0, end = 0.8, option = "A") # palette
cols <- palette[round(((imp - min(imp)) / diff(range(imp))) * (res-1)) + 1] # colors
# x labels
labels <- c()
for (i in combined.df$model) {
rep <- toupper(regmatches(i, regexpr("(?<=\\.)[a-zA-Z]+", i, perl = TRUE)))
if (rep == "OTHERS") {
rep <- "Others"
} else if (rep == "UNKNOWN") {
rep <- "Unidtf"
}
if (grepl(":", i)) {
type <- "int."
} else if (sub("\\..*", "", i) == "prop") {
type <- "prop."
} else {
type <- "age"
}
labels <- c(labels, paste(rep, type))
}
par(oma = c(0, 0, 3, 0))
layout(matrix(1:2, ncol = 2), widths = c(4, 1)) # make 2 plots
# main plot
par(mar = c(8, 4, 1, 0))
int.range <- range(as.matrix(combined.df[c("lower", "upper")])) * 1.2
int.range[2] <- int.range[2] * 1.2
plot(y = combined.df$estimate, x = x, type = "n", ylim = int.range,
ylab = "β coefficient", xlab = NA, axes = FALSE,
xlim = c(min(x)-0.25, max(x)+0.25), useRaster = T) # plot
abline(h = 0, lty = 1, col = "black") # line at y = 0
for (l in -100:100) {
abline(h = l, lty = 2, col = "grey") # line at y = 0
}
segments(x, combined.df$lower, x, combined.df$upper, lwd = 2) # confidence bars
segments(x-0.1, combined.df$upper, x+0.1, combined.df$upper, lwd = 2)
segments(x-0.1, combined.df$lower, x+0.1, combined.df$lower, lwd = 2)
points(x, combined.df$estimate, pch = 16, cex = 0.9, col = cols) # colored points
axis(2) # y axis
axis(2, at = seq(-10, 10, by = 0.5), labels = FALSE, tcl = -0.2)
axis(2, at = seq(-10, 10, by = 1), labels = FALSE, tcl = -0.5)
axis(1, at = x, labels = labels, las = 2) # x axis
box()
# color bar
par(mar = c(8, 1, 1, 4))
height <- seq(min(imp), max(imp), length.out = res + 1) # y values
z <- matrix(seq(min(imp), max(imp), length.out = res), nrow = 1, ncol = res) # color gradient
image(x = c(0, 1), y = height, z = z, col = palette,
axes = FALSE, xlab = "", ylab = "", useRaster = T) # make color bar
ticks <- seq(min(imp), max(imp), length.out = 5) # ticks
axis(4, at = ticks, labels = round(ticks, 2), las = 1) # y axis
# title
# mtext("Parameter estimates for averaged models",
#       outer = TRUE, cex = 1.1, line = 0, font = 2, family = "sans",
#       adj = 0.35)
par(mar = c(5, 4, 4, 2) + 0.1)
View(combined.df)
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat.results.csv")
combined.df <- data.frame()
# loop for each clade
i <- "All"
# subset results
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (i %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% i, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
age <- dat[grep("^age\\.", colnames(dat))]
prop <- dat[grep("^prop\\.", colnames(dat))]
View(prop)
View(age)
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat.results.csv")
combined.df <- data.frame()
# loop for each clade
# subset results
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (i %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% i, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
age <- dat[grep("^age\\.", colnames(dat))]
prop <- dat[grep("^prop\\.", colnames(dat))]
l <- age #TODO
dat <- cbind(dat[, c("species", "clade", "rsq")], l)
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat.results.csv")
combined.df <- data.frame()
# loop for each clade
i <- "All"
# subset results
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (i %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% i, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
age <- dat[grep("^age\\.", colnames(dat))]
prop <- dat[grep("^prop\\.", colnames(dat))]
l <- age #TODO
dat <- cbind(dat[, c("species", "clade", "rsq")], l)
variables <- variables[c(2, 4, 6, 8, 10, 12)]
# prune tree
tree <- read.tree("../data/formatted.tree.nwk")
int <- intersect(dat$species, tree$tip.label)
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# cd <- comparative.data(pruned.tree, dat, names.col = "species", vcv = TRUE)
# global model
# global.model <- glm(reformulate(variables, response = "rsq"), data = dat)
global.model <- glm(reformulate(variables, response = "rsq"), data = dat, weights = prop)
install.packages("eivtools")
library(eivtools)
library(eivtools)
# 1a) Install remotes if you don’t already have it
install.packages("remotes")                                   # :contentReference[oaicite:0]{index=0}
# 1b) (Re)install JAGS on your system first:
#    • Windows: https://cran.r-project.org/bin/windows/contrib/jags.html
#    • macOS:    https://sourceforge.net/projects/mcmc-jags/
#    • Linux:    via your distro’s package manager
#    See README in jrlockwood/eivtools for details :contentReference[oaicite:1]{index=1}
# 1c) Install R2jags (CRAN) so that eivtools can call JAGS
install.packages("R2jags")                                    # :contentReference[oaicite:2]{index=2}
# 1d) Install eivtools from GitHub
remotes::install_github("jrlockwood/eivtools")               # :contentReference[oaicite:3]{index=3}
library(eivtools)
# Make sure JAGS + R2jags are installed first (see above)
install.packages("R2jags")
# Install the archived eivtools source
install.packages(
"https://cran.r-project.org/src/contrib/Archive/eivtools/eivtools_0.1-8.tar.gz",
repos = NULL,
type  = "source"
)                                                              # :contentReference[oaicite:6]{index=6}
library(eivtools)
remotes::install_version("eivtools",
version = "0.1-8",
repos   = "https://cran.r-project.org",
dependencies = TRUE)
library(eivtools)
install.packages(
"https://cran.r-project.org/src/contrib/Archive/eivtools/eivtools_0.1-8.tar.gz",
repos = NULL,
type  = "source",
dependencies = TRUE
)
library(eivtools)
install.packages("rjags", type = "source", dependencies = TRUE)
library(rjags)
# install eivtools (from CRAN archive or GitHub, as before)
remotes::install_version("eivtools", version="0.1-8", dependencies=TRUE)
library(eivtools)
install.packages("rjags", type = "source", dependencies = TRUE)
library(rjags)
Sys.setenv(JAGS_HOME="C:/Program Files/JAGS/JAGS-4.3.1")  # adjust to your version/path :contentReference[oaicite:2]{index=2}
library(rjags)
.rs.restartR()
# From within R, remove the package record
remove.packages("rjags")           # removes package metadata but may leave files behind
install.packages("rjags", type = "source", dependencies = TRUE)   # forces recompilation :contentReference[oaicite:6]{index=6}
library(rjags)                                                  # confirm it now loads :contentReference[oaicite:7]{index=7}
Sys.setenv(JAGS_HOME="C:/Program Files/JAGS/JAGS-4.3.2")
install.packages("rjags", type="source", dependencies=TRUE)
library(rjags)    # should succeed without “Console.h” errors
install.packages(
"rjags",
type = "source",
configure.args = c(
"--with-jags-include=C:/progra~1/JAGS/JAGS-4.3.2/include",
"--with-jags-lib=C:/progra~1/JAGS/JAGS-4.3.2/lib"
),
dependencies = TRUE
)
library(devtools)
devtools::install_github("jrlockwood/eivtools")
Sys.setenv(JAGS_HOME="C:/Program Files/JAGS/JAGS-4.3.2")
install.packages("rjags")
devtools::install_github("jrlockwood/eivtools")
Sys.setenv(JAGS_HOME="C:\\Program Files\\JAGS\\JAGS-4.3.2")
install.packages("rjags", configure.args="--with-jags-include=$(JAGS_HOME)/include/JAGS --with-jags-lib=$(JAGS_HOME)/lib")
library(rjags)
Sys.getenv("JAGS_HOME")
install.packages("runjags")
library(runjags)
testjags()
library(MuMIn) # multimodel inference
library(phytools) # load and prune tree
library(caper) # PGLS
options(na.action = "na.fail")
# functions
source("functions.R")
rsq <- read.csv("../results/rsq.csv")
repeats <- read.csv("../results/repeat.results.csv")
combined.df <- data.frame()
i <- "All"
# subset results
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (i %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% i, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
age <- dat[grep("^age\\.", colnames(dat))]
prop <- dat[grep("^prop\\.", colnames(dat))]
l <- age #TODO
dat <- cbind(dat[, c("species", "clade", "rsq")], l)
variables <- variables[c(2, 4, 6, 8, 10, 12)]
# prune tree
tree <- read.tree("../data/formatted.tree.nwk")
int <- intersect(dat$species, tree$tip.label)
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# cd <- comparative.data(pruned.tree, dat, names.col = "species", vcv = TRUE)
# global model
# global.model <- glm(reformulate(variables, response = "rsq"), data = dat)
global.model <- glm(reformulate(variables, response = "rsq"), data = dat, weights = prop)
# subset results
dat <- merge(rsq, repeats, by.x = "species", by.y = "species", all.x = T, all.y = T)
if (i %in% c("Mammalia", "Actinopterygii", "Sauropsida")) {
dat <- dat[dat$clade %in% i, ]
}
variables <- colnames(dat)[grep("^(prop|age)\\.", colnames(dat))]
dat <- na.omit(dat[, c("species", "clade", "rsq", variables)])
age <- dat[grep("^age\\.", colnames(dat))]
prop <- dat[grep("^prop\\.", colnames(dat))]
l <- age #TODO
dat <- cbind(dat[, c("species", "clade", "rsq")], l)
variables <- variables[c(2, 4, 6, 8, 10, 12)]
# prune tree
tree <- read.tree("../data/formatted.tree.nwk")
int <- intersect(dat$species, tree$tip.label)
# rescale
for (j in variables) {
dat[[j]] <- (dat[[j]]-min(dat[[j]])) / diff(range(dat[[j]]))
}
# global model
# global.model <- glm(reformulate(variables, response = "rsq"), data = dat)
global.model <- glm(reformulate(variables, response = "rsq"), data = dat, weights = prop)
